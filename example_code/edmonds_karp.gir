function dag augment(dag flow, dag path) {
	/* Get bottleneck capacity of path. */
	int min = -1;
	for_edge (e : path) {
		if (min > e.weight) {
			min = e.weight;
		}
	}

	/* Augment flow. */
	for_edge (e : path) {
		if (flow.has_edge(e.from, e.to)) {
			int current_flow = flow.get_edge(e.from, e.to).weight;
			/* Add bottleneck capacity to current flow. */
			flow.add_edge(e.from, e.to, current_flow + min);
		} else {
			int current_flow = flow.get_edge(e.to, e.from).weight;
			/* Subtract bottleneck capacity from current flow. */
			flow.add_edge(e.to, e.from, current_flow - min);
		}
	}
	return flow;
}

function digraph make_residual_graph(dag flow, dag network) {
	digraph residual_graph;
	for_edge (e : flow) {
		int forward = network.get_edge(e.from, e.to).weight - e.weight;
		int backward = e.weight;
		if (forward > 0) {
			residual_graph.add_edge(e.from, e.to, forward);
		}
		if (backward > 0) {
			residual_graph.add_edge(e.to, e.from, backward);
		}
	}
	return residual_graph;
}

function dag edmonds_karp(dag network) {
	/* The argument “network” contains the capacities as weights on edges.
	   Flow is represented with a graph exactly equivalent to network, but 
	   with the flow on each edge as the weight instead of the capacity.
	   First, set up initial flow of 0 on every edge. */
	dag flow;
	for_edge (e : network) {
		flow.add_edge(e.from, e.to, 0);
	}
	dag residual = make_residual_graph(flow, network);
	while (true) {
		map parents;
		/* Find shortest s-t path with BFS. */
		bfs (n : residual ; network.source) {
			for_node (neighbor : residual.get_neighbors(n)) {
				/* ^ this means get_neighbors returns an edgeless graph! woah!*/
				if (!parents.contains_key(neighbor)) {
					parents[neighbor] = n;
				}
			}
		}
		/* If we didn’t reach the sink, there is no s-t path in residual */
		if (!parents.contains_key(i)) {
			break;
		}
		dag path; 
		node i = network.sink;
		while (i != network.source) {
			path.add_edge(parents[i], i, residual.get_edge(parents[i], i).weight);
			i = parents[i];
		}
		flow = augment(flow, path);
	}
	return flow;
}

function void main() {
	dag network = A -[100]-> (B -[100]-> D, C -[100]-> D)
				  B -[1]-> C;
	dag max_flow = edmonds_karp(network);
	render(max_flow);
}